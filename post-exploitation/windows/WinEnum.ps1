Write-Host "Enumerating Binary Hijacking:" -ForegroundColor Green

# Binary Hijack
Write-Host ""
$results = Get-CimInstance -ClassName win32_service | Where-Object { $_.PathName -ne $null -and $_.PathName.ToLower() -notlike '*c:\windows\*' } | ForEach-Object {
    $servicePath = $_.PathName.Trim() -replace '^(.*?\.[\w\d]+)\s+.*', '$1' -replace '%windir%', '$env:WINDIR'  -replace '%SystemRoot%', '$env:SystemRoot'
    $acl = $null
    
    try {
        $acl = Get-Acl -Path $servicePath -ErrorAction SilentlyContinue
        if ($acl) {
            $currentUser = [System.Security.Principal.WindowsIdentity]::GetCurrent()
            $userGroups = $currentUser.Groups | ForEach-Object { $_.Translate([System.Security.Principal.NTAccount]).Value }

            $access = $acl.Access | Where-Object { 
                ($_.IdentityReference -eq $currentUser.Name) -or  ($userGroups -contains $_.IdentityReference.Translate([System.Security.Principal.NTAccount]).Value)
            } | Where-Object { $_.FileSystemRights -match 'Write' -or $_.FileSystemRights -match 'FullControl' }

            if ($access) {
                $service = Get-Service -Name $_.Name
                $permissions = $service | Select-Object -Property CanStart, CanStop, CanPauseAndContinue, CanShutdown | ForEach-Object { 
                    $_.PSObject.Properties | Where-Object { $_.Value -eq $true } | ForEach-Object { "$($_.Name): $($_.Value)" } 
                }

                [PSCustomObject]@{
                    'ServiceName' = $_.Name
                    'serviceState' = $_.State
                    'WritableBinaries' = $servicePath
                    'Permissions' = $permissions -join ", "
                }
            }
        }
    } catch {}
}

if ($results) {
    $results | Format-Table -Property ServiceName, serviceState, WritableBinaries, @{Name='Permissions'; Expression={$_.Permissions -join ', '}} -AutoSize -Wrap

}

Write-Host "_____________________________"
Write-Host ""
Write-Host "Enumerating Unquoted Path Services:" -ForegroundColor Green

# Unquoted Path
$results = Get-WmiObject -Class Win32_Service | Where-Object { $_.PathName -ne $null -and $_.PathName.ToLower() -notlike '*c:\windows\*' -and $_.PathName -notlike '"*' } | ForEach-Object {
    $servicePath = $_.PathName.Trim() -replace '^(.*?\.[\w\d]+)\s+.*', '$1' -replace '%windir%', '$env:WINDIR'  -replace '%SystemRoot%', '$env:SystemRoot'
    $writablePaths = @()
    $pathParts = $servicePath.Split('\')
    $currentPath = 'C:\'

    if ($servicePath -notlike '* *') {
        return
    } 
    
    foreach ($part in $pathParts) {
        if ($part -ne '' -and $part -notlike '*.exe' -and $part -ne 'C:') {
            $currentPath = Join-Path -Path $currentPath -ChildPath $part
            $acl = $null
            
            try {
                $acl = Get-Acl -Path $servicePath -ErrorAction SilentlyContinue
                if ($acl) {
                    $currentUser = [System.Security.Principal.WindowsIdentity]::GetCurrent()
                    $userGroups = $currentUser.Groups | ForEach-Object { $_.Translate([System.Security.Principal.NTAccount]).Value }

                    $access = $acl.Access | Where-Object { 
                        ($_.IdentityReference -eq $currentUser.Name) -or  ($userGroups -contains $_.IdentityReference.Translate([System.Security.Principal.NTAccount]).Value)
                    } | Where-Object { $_.FileSystemRights -match 'Write' -or $_.FileSystemRights -match 'FullControl' }

                    if ($access) {
                        $writablePaths += $currentPath
                    }
                }
            } catch {}
        }
    }

    if ($writablePaths) {
        [PSCustomObject]@{
            'ServiceName' = $_.Name
            'ServicePath' = $servicePath
            'WritablePaths' = $writablePaths -join "`n"
        }
    }
}

if ($results) {
    $results | Format-Table -Property ServiceName, ServicePath, WritablePaths -AutoSize -Wrap
}

Write-Host "_____________________________"
Write-Host ""
Write-Host "Enumerating Scheduled Tasks:" -ForegroundColor Green

# Scheduled Tasks
$adminUsers = net localgroup administrators | Select-String -Pattern "^\s*(.*)\s*$" | ForEach-Object { $_.Matches.Groups[1].Value }

$results = schtasks.exe /query /V /FO CSV | ConvertFrom-Csv | Where-Object { 
    ($_.Status -eq "Ready") -and ($_.'task to run' -like '*.exe*') -and 
    (($_.'Next Run Time' -gt (Get-Date)) -or ($_.'Schedule Type' -ne 'Undefined')) -and 
    (($_.'Run As User' -eq "SYSTEM") -or ($adminUsers -contains $_.'Run As User'))

} | ForEach-Object {
    $servicePath = $_.'task to run'.Trim() -replace '^(.*?\.[\w\d]+)\s+.*', '$1' -replace '%windir%', '$env:WINDIR'  -replace '%SystemRoot%', '$env:SystemRoot'

    $BinaryHijack = ""
    try {
        $acl = Get-Acl -Path $servicePath -ErrorAction SilentlyContinue
        if ($acl) {
            $currentUser = [System.Security.Principal.WindowsIdentity]::GetCurrent()
            $userGroups = $currentUser.Groups | ForEach-Object { $_.Translate([System.Security.Principal.NTAccount]).Value }

            $access = $acl.Access | Where-Object { 
                ($_.IdentityReference -eq $currentUser.Name) -or  ($userGroups -contains $_.IdentityReference.Translate([System.Security.Principal.NTAccount]).Value)
            } | Where-Object { $_.FileSystemRights -match 'Write' -or $_.FileSystemRights -match 'FullControl' }
            if ($access) {
                $BinaryHijack = "Yes"
            }
        }
    } catch {}

    $writablePaths = @()
    $pathParts = $servicePath.Split('\')
    $currentPath = 'C:\'

    if ($servicePath -like '* *') {
        foreach ($part in $pathParts) {
            if ($part -ne '' -and $part -notlike '*.exe' -and $part -ne 'C:') {
                $currentPath = Join-Path -Path $currentPath -ChildPath $part
                $acl = $null
            
                try {
                    $acl = Get-Acl -Path $servicePath -ErrorAction SilentlyContinue
                    if ($acl) {
                        $currentUser = [System.Security.Principal.WindowsIdentity]::GetCurrent()
                        $userGroups = $currentUser.Groups | ForEach-Object { $_.Translate([System.Security.Principal.NTAccount]).Value }

                        $access = $acl.Access | Where-Object { 
                            ($_.IdentityReference -eq $currentUser.Name) -or  ($userGroups -contains $_.IdentityReference.Translate([System.Security.Principal.NTAccount]).Value)
                        } | Where-Object { $_.FileSystemRights -match 'Write' -or $_.FileSystemRights -match 'FullControl' }

                        if ($access) {
                            $writablePaths += $currentPath
                        }
                    }
                } catch {}
            }
        }
    }

    $TaskName = $_.TaskName
    $NextRunTime = $_.'Next Run Time'
    $RunOn = $_.'Schedule Type'
    $RunAsUser = $_.'Run As User'
    $Action = $_.'task to run'

    [PSCustomObject]@{
        TaskName = $TaskName
        NextRunTime = $NextRunTime
        RunOn = $RunOn
        RunAsUser = $RunAsUser
        BinaryHijack = $BinaryHijack
        PathHijack = $writablePaths -join "`n"
        Action = $Action -join "`n"
    }
}

if ($results) {
    $results | Format-Table -AutoSize -Wrap
}

Write-Host "_____________________________"
Write-Host ""
Write-Host "Enumerating Privileges:" -ForegroundColor Green

# Privileges
$results = whoami /priv /fo csv | ConvertFrom-Csv | Where-Object { $_."Privilege Name" -in @("SeImpersonatePrivilege", "SeBackupPrivilege", "SeAssignPrimaryToken", "SeLoadDriver", "SeDebug") }

if ($results) {
    $results | Format-Table -Property "Privilege Name", "State" -AutoSize -Wrap
}