#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Done
"""
- Unconstrained Delegation
- Constrained Delegation
- Resource-Based Constrained Delegation
- Users with SPN (Kerberoastable)
- AS-REP Roastable Users
- Interesting ACLs
- Sensitive Descriptions (pass / pwd)
- Find dangerous permissions
- High Privileged Users (adminCount=1)
- Users With Remote Access to Computers
- Users with Foreign Domain Group Membership
- Foreign Group to Internal Group (Recursive Membership)
- Domain Trusts
- Paths to High Privilege (Domain/Enterprise Admins)
- Export Users and Computers
- Neo4j integration to get owned sids
- Accounts con "TrustedForDelegation" + SPN
- Computers con sesiones activas (Sessions)
- Overpass-the-Hash / Pass-the-Key detection

- Shadow Credentials (msDS-KeyCredentialLink) (Pending test)
- GMSA Accounts (Group Managed Service Accounts) (Pending test)
- Writable GPOs (Pending test)
"""

# To-Do
"""
"""


import os
import json
import tempfile
import argparse
import networkx as nx
from zipfile import ZipFile
from rich import box
from rich.text import Text
from rich.table import Table
from rich.console import Console
from neo4j import GraphDatabase

console = Console()
sid_to_name = {}
sid_to_type = {}
domain_controllers_sids = set()
privileged_sids = set()
owned_sids = set()
decorations = {
    "user": {
        "color": "green",
        "icon": ""
    },
    "group": {
        "color": "yellow",
        "icon": ""
    },
    "computer": {
        "color": "magenta",
        "icon": "️"
    },
    "domain": {
        "color": "yellow",
        "icon": ""
    },
    "ou": {
        "color": "cyan",
        "icon": ""
    },
    "container": {
        "color": "white",
        "icon": ""
    },
    "gpo": {
        "color": "purple",
        "icon": "️"
    }
}


def extract_zip(zip_paths):
    temp_dir = tempfile.mkdtemp()
    for zip_path in zip_paths:
        with ZipFile(zip_path, 'r') as zip_ref:
            zip_ref.extractall(temp_dir)
    return temp_dir


def find_files(directory, keyword):
    return [os.path.join(directory, f) for f in os.listdir(directory) if keyword in f.lower()]


def load_json_data(path):
    try:
        with open(path, 'r', encoding='utf-8-sig') as f:
            content = json.load(f)
            return content.get("data", [])
    except Exception:
        return []


def export_object_list(dir, type_filter, output_file):
    exported = set()
    for file in find_files(dir, f"{type_filter}.json"):
        for entry in load_json_data(file):
            name = entry.get("Properties", {}).get("name")
            if name and name not in exported:
                exported.add(name)
    with open(output_file, "w", encoding="utf-8") as f:
        for item in sorted(exported):
            f.write(f"{item}\n")
    console.print(f"[green]Exported {len(exported)} {type_filter} to {output_file}[/]")


def build_sid_map(dir):
    global sid_to_name

    property_files = ["users", "groups", "computers", "domains", "ous", "containers", "gpos"]
    for keyword in property_files:
        for file in find_files(dir, f"{keyword}.json"):
            for entry in load_json_data(file):
                sid = entry.get("ObjectIdentifier")
                nombre = entry.get("Properties", {}).get("name")
                if sid and nombre:
                    sid_to_name[sid] = nombre
                    sid_to_type[sid] = keyword[:-1]


def get_sid_by_name(name):
    name = name.upper()
    for sid, n in sid_to_name.items():
        if n.upper() == name:
            return sid
    return None


def format_object(sid, name=None):
    global owned_sids, privileged_sids

    type = sid_to_type.get(sid, "N/A")
    icon = decorations.get(type, {}).get("icon", "")
    color = decorations.get(type, {}).get("color", "cyan")
    name = name or sid_to_name.get(sid, sid)

    skull = "" if sid in owned_sids else ""
    star = "" if sid in privileged_sids else ""

    return Text(f"{icon} {name} {skull}{star}", style=color)


def get_domain_controllers_sids(dir):
    global domain_controllers_sids

    dc_spn_indicators = [
        "ldap/",
        "GC/",
        "krbtgt/",
        "kadmin/",
        "DnsZones",
        "ForestDnsZones"
    ]
    for file in find_files(dir, "computers.json"):
        for entry in load_json_data(file):
            props = entry.get("Properties", {})
            sid = entry.get("ObjectIdentifier")
            spns = props.get("serviceprincipalnames", [])
            if any(any(indicator.lower() in spn.lower() for indicator in dc_spn_indicators) for spn in spns):
                domain_controllers_sids.add(sid)


def get_privileged_sids(dir):
    global privileged_sids
    
    for file in find_files(dir, "groups.json"):
        for entry in load_json_data(file):
            group_name = entry.get("Properties", {}).get("name", "").upper()
            group_sid = entry.get("ObjectIdentifier")
            if any(p in group_name for p in [
                "DOMAIN ADMINS", "ENTERPRISE ADMINS", "ADMINISTRATORS",
                "BACKUP OPERATORS", "ACCOUNT OPERATORS", "SERVER OPERATORS",
                "KRBTGT", "DNSADMINS", "KEY ADMINS", "RAS AND IAS SERVERS",
                "ENTERPRISE DOMAIN CONTROLLERS", "DOMAIN CONTROLLERS", "SCHEMA ADMINS"
            ]):
                if group_sid:
                    privileged_sids.add(group_sid)
                for member in entry.get("Members", []):
                    sid = member.get("ObjectIdentifier")
                    if sid:
                        privileged_sids.add(sid)


def get_owned_sids_from_neo4j():
    uri = 'bolt://localhost:7687'
    user = 'neo4j'
    password = 'kali'
    driver = GraphDatabase.driver(uri, auth=(user, password))
    owned = set()

    query = """
    MATCH (n)
    WHERE n.owned = true AND n.objectid IS NOT NULL
    RETURN n.objectid AS sid
    """

    with driver.session() as session:
        results = session.run(query)
        for record in results:
            sid = record["sid"]
            if sid:
                owned.add(sid)

    driver.close()
    return owned


def check_unconstrained_delegation(dir):
    global domain_controllers_sids

    rows = []
                        
    for file in find_files(dir, "computers.json"):
        for entry in load_json_data(file):
            props = entry.get("Properties", {})
            sid = entry.get("ObjectIdentifier")
            if props.get("unconstraineddelegation", False) and sid not in domain_controllers_sids:
                ou = " / ".join(part[3:] for part in props.get("distinguishedname", "").split(",") if part.startswith("OU="))
                dc_obj = Text(decorations['computer']['icon'] + " " + props.get("name", "N/A"), style=decorations['computer']['color'])

                spns = props.get("serviceprincipalnames", [])
                dc_spn_indicators = ["ldap/", "GC/", "krbtgt/", "kadmin/", "DnsZones", "ForestDnsZones"]
                kerberoastable = any(all(dc_indicator.lower() not in spn.lower() for dc_indicator in dc_spn_indicators) for spn in spns)

                rows.append([dc_obj, props.get("operatingsystem", "N/A"), ou or "N/A", "✅" if kerberoastable else "❌"])
    return rows


def check_constrained_delegation(dir):
    global owned_sids

    rows = []
    for file in find_files(dir, "computers.json"):
        for entry in load_json_data(file):
            props = entry.get("Properties", {})
            if props.get("trustedtoauth", False):
                dc_obj = format_object(get_sid_by_name(props.get("name", "N/A")))
                rows.append([dc_obj, "ProtocolTransition"])
    return rows


def check_rbcd(dir):
    global owned_sids
    
    rows = []
    for file in find_files(dir, "computers.json"):
        for entry in load_json_data(file):
            if "AllowedToAct" in entry and entry["AllowedToAct"]:
                for act in entry["AllowedToAct"]:
                    obj1 = format_object(get_sid_by_name(entry["Properties"]["name"]))
                    obj2 = format_object(get_sid_by_name(act.get("PrincipalName", "N/A")))
                    rows.append([obj1, obj2])
    return rows


def check_users_with_spn(dir):
    global owned_sids
    
    rows = []
    for file in find_files(dir, "users.json"):
        for entry in load_json_data(file):
            props = entry.get("Properties", {})
            spns = props.get("serviceprincipalnames", [])
            if spns and props.get("name").startswith("KRBTGT@") is False:
                user_obj = format_object(get_sid_by_name(props.get("name", "N/A")))
                rows.append([user_obj, ", ".join(spns)])
    return rows


def check_admin_count(dir):
    global owned_sids
    
    rows = []
    for file in find_files(dir, "users.json"):
        for entry in load_json_data(file):
            props = entry.get("Properties", {})
            if props.get("admincount", 0) == 1:
                obj = format_object(get_sid_by_name(props.get("name", "N/A")))
                rows.append([obj, props.get("distinguishedname", "N/A")])
    return rows


def check_trusts(dir):
    global owned_sids

    rows = []
    domain_data = {}
    seen_trusts = set()

    for file in find_files(dir, "domains.json"):
        for entry in load_json_data(file):
            domain_sid = entry.get("ObjectIdentifier")
            domain_name = entry.get("Properties", {}).get("name", "N/A")
            trusts = entry.get("Trusts", [])
            domain_data[domain_sid] = {
                "name": domain_name,
                "trusts": trusts
            }

    for source_sid, source_info in domain_data.items():
        source_name = source_info["name"]
        for trust in source_info["trusts"]:
            target_sid = trust.get("TargetDomainSid")
            target_name = trust.get("TargetDomainName", "N/A")
            direction = trust.get("TrustDirection", 0)
            trust_type = trust.get("TrustType", 0)
            transitive = trust.get("IsTransitive", True)
            selective_auth = trust.get("IsSelectiveAuth", False)
            sid_filtering = trust.get("SidFilteringEnabled", True)

            key = tuple(sorted([source_sid, target_sid or target_name]))
            if key in seen_trusts:
                continue
            seen_trusts.add(key)

            direction_str = {
                0: "Disabled",
                1: "Inbound",
                2: "Outbound",
                3: "Bidirectional"
            }.get(direction, str(direction))

            trust_type_str = {
                0: "Disabled/Unknown",
                1: "Windows",
                2: "Kerberos",
                3: "MIT",
                4: "DCE"
            }.get(trust_type, str(trust_type))

            abuses = []

            if trust_type == 2 and transitive and direction in {2, 3} and not selective_auth:
                abuses.append("Possible lateral movement (SPN abuse / Silver Ticket with service account hash)")

            if direction in {1, 3} and trust_type == 2 and not selective_auth:
                if sid_filtering:
                    abuses.append("Golden Ticket (Possible false positive)")
                else:
                    abuses.append("Golden Ticket")

            if not sid_filtering:
                abuses.append("SIDHistory")

            abuse_text = Text("\n".join(abuses), style="red" if abuses else "grey62")
            source_obj = format_object(get_sid_by_name(source_name))

            if target_sid in domain_data:
                skull = "" if target_sid in owned_sids else ""
                target_name = domain_data[target_sid]["name"]
                target_obj = Text(f"{decorations['domain']['icon']}{skull} {target_name}", style=decorations['domain']['color'])
            else:
                target_obj = Text(f"{decorations['domain']['icon']} {target_name}", style=decorations['domain']['color'])

            rows.append([source_obj, f"{direction_str} ({trust_type_str})", target_obj, abuse_text])

    return rows


def check_domain_admins(dir):
    global owned_sids
    
    rows = []
    for file in find_files(dir, "groups.json"):
        for entry in load_json_data(file):
            group_name = entry.get("Properties", {}).get("name", "").upper()
            if group_name.startswith("DOMAIN ADMINS") or group_name.startswith("ENTERPRISE ADMINS"):
                for member in entry.get("Members", []):
                    sid = member.get("ObjectIdentifier", "N/A")
                    user_obj = format_object(sid)
                    group_obj = format_object(get_sid_by_name(group_name))
                    rows.append([user_obj, group_obj])
    return rows


def check_interesting_acls(dir):
    global privileged_sids, owned_sids
    rows = []
    interesting_rights = {
        "GenericAll", "GenericWrite", "WriteDacl", "WriteOwner",
        "AllExtendedRights", "ResetPassword", "CreateChild", "DeleteChild",
        "AddMember", "WriteSPN", "ForceChangePassword", "ReadGMSAPassword",
        "ReadLAPSPassword", "WriteProperty", "Owns"
    }

    for file in find_files(dir, "acls.json"):
        for entry in load_json_data(file):
            ace_type = entry.get("AceType")
            right_name = entry.get("RightName")
            if ace_type in interesting_rights or right_name in interesting_rights:
                principal = entry.get("PrincipalName", "N/A")
                sid = get_sid_by_name(principal)
                if sid in privileged_sids:
                    continue
                target = entry.get("TargetName", "N/A")
                privilege = ace_type if ace_type in interesting_rights else right_name
                principal_obj = format_object(get_sid_by_name(principal))
                rows.append([principal_obj, privilege, target])

    for keyword in ["computers", "users", "groups", "containers", "domains", "gpos", "ous"]:
        for file in find_files(dir, f"{keyword}.json"):
            for entry in load_json_data(file):
                target = entry.get("Properties", {}).get("name", "N/A")
                aces = entry.get("Aces", [])
                for ace in aces:
                    ace_type = ace.get("AceType")
                    right_name = ace.get("RightName")
                    privilege = ace_type if ace_type in interesting_rights else right_name
                    if privilege in interesting_rights:
                        sid = ace.get("PrincipalSID", "")
                        principal = sid_to_name.get(sid)
                        if not principal:
                            principal = sid.upper()
                        if not principal:
                            principal = ace.get("PrincipalName") or sid
                        sid = ace.get("PrincipalSID", "")
                        if sid in privileged_sids:
                            continue

                        principal_obj = format_object(get_sid_by_name(principal))
                        target_obj = format_object(get_sid_by_name(target))
                        
                        if sid_to_type.get(sid) == "group":
                            for file in find_files(dir, "groups.json"):
                                for group_entry in load_json_data(file):
                                    if group_entry.get("ObjectIdentifier") == sid:
                                        for member in group_entry.get("Members", []):
                                            member_sid = member.get("ObjectIdentifier")
                                            member_name = sid_to_name.get(member_sid, member_sid)
                                            member_type = sid_to_type.get(member_sid, "N/A")
                                            icon = decorations[member_type]['icon'] if member_type in decorations else ""
                                            color = decorations[member_type]['color'] if member_type in decorations else "cyan"
                                            skull = "" if get_sid_by_name(member_sid) in owned_sids else ""
                                            line = Text(f"\n  ↳ {icon}{skull} {member_name}", style=color)
                                            principal_obj.append(line)
                                        break
                        
                        rows.append([principal_obj, privilege, target_obj])
    
    return rows


def find_sensitive_descriptions(dir):
    global owned_sids
    
    rows = []
    keywords = ["pass", "pwd"]
    for file in find_files(dir, "users.json") + find_files(dir, "computers.json"):
        for entry in load_json_data(file):
            props = entry.get("Properties", {})
            desc = (props.get("description") or "").lower()
            if any(k in desc for k in keywords):
                obj = format_object(get_sid_by_name(props.get("name", "N/A")))
                rows.append([obj, props.get("description", "N/A")])
    return rows


def find_dangerous_permissions(dir):
    global owned_sids
    
    rows = []
    rights_needed = [
        "DS-Replication-Get-Changes",
        "DS-Replication-Get-Changes-All",
        "DS-Replication-Get-Changes-In-Filtered-Set"
    ]
    for file in find_files(dir, "acls.json"):
        for entry in load_json_data(file):
            if (entry.get("RightName") in rights_needed and "DOMAIN" in entry.get("TargetName", "").upper()) or entry.get("RightName") == "ReadGMSAPassword" or entry.get("RightName") == "ReadLAPSPassword":
                principal_obj = format_object(get_sid_by_name(entry.get("PrincipalName", "N/A")))
                target_obj = format_object(get_sid_by_name(entry.get("TargetName", "N/A")))
                rows.append([principal_obj, entry.get("RightName", "N/A"), target_obj])
    return rows


def find_asrep_roastable_users(dir):
    global owned_sids
    
    rows = []
    for file in find_files(dir, "users.json"):
        for entry in load_json_data(file):
            props = entry.get("Properties", {})
            if props.get("dontreqpreauth", False):
                obj = format_object(get_sid_by_name(props.get("name", "N/A")))
                rows.append([obj, props.get("distinguishedname", "N/A")])
    return rows


def find_paths_to_high_privilege(dir):
    global privileged_sids, owned_sids

    G = nx.DiGraph()
    
    all_files = find_files(dir, ".json")
    for file in all_files:
        for entry in load_json_data(file):
            oid = entry.get("ObjectIdentifier")
            name = entry.get("Properties", {}).get("name")
            if oid and name:
                G.add_node(oid, label=name)
    
    for file in find_files(dir, ".json"):
        for entry in load_json_data(file):
            member = entry.get("MemberId")
            group = entry.get("GroupId")
            if member and group:
                G.add_edge(member, group, type="MemberOf")
    
    interesting_edges = {"GenericAll", "WriteDacl", "AddMember", "ResetPassword", "WriteSPN", "Owns", "WriteOwner", "AllExtendedRights"}
    for file in find_files(dir, ".json"):
        for entry in load_json_data(file):
            target = entry.get("ObjectIdentifier")
            aces = entry.get("Aces", [])
            for ace in aces:
                source = ace.get("PrincipalSID")
                right = ace.get("RightName") or ace.get("AceType")
                if source and target and right in interesting_edges:
                    G.add_edge(source, target, type=right)

    for file in find_files(dir, "groups.json"):
        for entry in load_json_data(file):
            group_sid = entry.get("ObjectIdentifier")
            for member in entry.get("Members", []):
                member_sid = member.get("ObjectIdentifier")
                if group_sid and member_sid:
                    G.add_edge(member_sid, group_sid, type="MemberOf")

    targets = set()
    for node in G.nodes:
        name = sid_to_name.get(node, "").upper()
        if name.startswith("DOMAIN ADMINS") or name.startswith("ENTERPRISE ADMINS") or name.startswith("ADMINISTRATORS") or name.startswith("BACKUP OPERATORS") or name.startswith("ACCOUNT OPERATORS") or name.startswith("SERVER OPERATORS") or get_sid_by_name(name) in domain_controllers_sids:
            targets.add(node)
    
    low_priv_users = set()
    for sid, name in sid_to_name.items():
        shortname = name.split("@")[0].upper()
        if sid in privileged_sids or shortname in {"ADMINISTRATORS", "ADMINISTRATOR", "BACKUP OPERATORS", "ACCOUNT OPERATORS", "SERVER OPERATORS", "KRBTGT"}:
            continue
        if name.split("@")[0].upper() not in {"ADMINISTRATOR", "KRBTGT"} and "@" in name:
            low_priv_users.add(sid)
    
    rows = []
    for user in low_priv_users:
        for target in targets:
            try:
                path = nx.shortest_path(G, user, target)
                if any(n in targets for n in path[1:-1]):
                    continue
                readable_path = Text()
                for i, node in enumerate(path):
                    nodo_text = format_object(node)
                    readable_path.append(nodo_text)
                    if i < len(path) - 1:
                        readable_path.append(" → ", style="white")
                
                from_obj = format_object(user)
                to_obj = format_object(target)
                rows.append([from_obj, to_obj, readable_path])
            except nx.NetworkXNoPath:
                continue

    return rows


def find_remote_access_users(dir):
    global sid_to_name, sid_to_type

    remote_access_rights = {
        "RemoteInteractiveLogon",  # RDP-like
        "ExecuteMethods",          # WMI
        "DCOM"                     # WinRM/DCOM
    }

    rows = []

    for file in find_files(dir, "acls.json"):
        for entry in load_json_data(file):
            target_name = entry.get("TargetName", "N/A")
            target_sid = get_sid_by_name(target_name)
            target_type = sid_to_type.get(target_sid, "computer")
            if target_type != "computer":
                continue

            right = entry.get("RightName") or entry.get("AceType")
            if right not in remote_access_rights:
                continue

            principal = entry.get("PrincipalName") or entry.get("PrincipalSID", "N/A")
            sid = get_sid_by_name(principal)

            if sid in privileged_sids:
                continue

            user_obj = format_object(get_sid_by_name(principal))
            comp_obj = format_object(get_sid_by_name(target_name))
            rows.append([user_obj, right, comp_obj])

    return rows


def find_foreign_group_memberships(dir):
    global privileged_sids, owned_sids

    rows = []

    for file in find_files(dir, "groups.json"):
        for entry in load_json_data(file):
            group_sid = entry.get("ObjectIdentifier")
            group_name = sid_to_name.get(group_sid, group_sid)

            for member in entry.get("Members", []):
                member_sid = member.get("ObjectIdentifier")
                member_name = sid_to_name.get(member_sid, member_sid)

                if member_sid in privileged_sids:
                    continue

                if "@" not in member_name or "@" not in group_name:
                    continue

                user_domain = member_name.split("@")[-1].lower()
                group_domain = group_name.split("@")[-1].lower()

                if user_domain != group_domain:
                    user_obj = format_object(get_sid_by_name(member_name))
                    group_obj = format_object(get_sid_by_name(group_name))
                    rows.append([user_obj, "MemberOf", group_obj])

    return rows


def find_foreign_group_membership_chains(dir):
    rows = []
    G = nx.DiGraph()

    for file in find_files(dir, "groups.json"):
        for entry in load_json_data(file):
            group_sid = entry.get("ObjectIdentifier")
            group_name = sid_to_name.get(group_sid, group_sid)

            for parent in entry.get("MemberOf", []):
                parent_sid = parent.get("ObjectIdentifier")
                G.add_edge(group_sid, parent_sid)

    for source_sid in G.nodes:
        source_name = sid_to_name.get(source_sid, "")
        if "@" not in source_name:
            continue

        source_domain = source_name.split("@")[-1].lower()
        if source_domain == "capsulecorp.local":
            continue

        for target_sid in G.nodes:
            if source_sid == target_sid:
                continue

            target_name = sid_to_name.get(target_sid, "")
            if "@" not in target_name:
                continue

            target_domain = target_name.split("@")[-1].lower()
            if target_domain == source_domain:
                continue

            try:
                path = nx.shortest_path(G, source=source_sid, target=target_sid)
                if len(path) > 1:
                    path_text = Text(" → ".join([sid_to_name.get(s, s) for s in path]), style="dim")
                    from_obj = format_object(get_sid_by_name(source_name))
                    to_obj = format_object(get_sid_by_name(target_name))
                    rows.append([from_obj, "MemberOf*", to_obj, path_text])
            except nx.NetworkXNoPath:
                continue

    return rows


def find_shadow_credentials(dir):
    global owned_sids

    rows = []
    for file in find_files(dir, "users.json") + find_files(dir, "computers.json"):
        for entry in load_json_data(file):
            props = entry.get("Properties", {})
            links = props.get("msds-keycredentiallink") or props.get("KeyCredentialLinks")
            if links:
                name = props.get("name", "N/A")
                obj = format_object(get_sid_by_name(name))
                rows.append([obj, str(links)])
    return rows


def find_gmsa_accounts(dir):
    global owned_sids

    rows = []
    for file in find_files(dir, "users.json"):
        for entry in load_json_data(file):
            props = entry.get("Properties", {})
            object_classes = [cls.lower() for cls in props.get("objectclass", [])]

            if any("msds-groupmanagedserviceaccount" in cls for cls in object_classes):
                name = props.get("name", "N/A")
                obj = format_object(get_sid_by_name(name))
                rows.append([obj, props.get("distinguishedname", "N/A")])
    return rows


def find_computers_with_sessions(dir):
    global owned_sids, sid_to_name, sid_to_type

    rows = []

    for file in find_files(dir, "computers.json"):
        for entry in load_json_data(file):
            comp_sid = entry.get("ObjectIdentifier")
            comp_obj = format_object(comp_sid)

            registry_sessions = entry.get("RegistrySessions", {})
            if not isinstance(registry_sessions, dict):
                continue

            for session in registry_sessions.get("Results", []):
                user_sid = session.get("UserSID")
                if not user_sid:
                    continue

                user_obj = format_object(user_sid)
                rows.append([user_obj, "Session on", comp_obj])

    return rows


def find_otp_pth_candidates(dir):
    global owned_sids

    rows = []
    for file in find_files(dir, "users.json"):
        for entry in load_json_data(file):
            props = entry.get("Properties", {})
            spns = props.get("serviceprincipalnames", [])
            dontreqpreauth = props.get("dontreqpreauth", False)
            name = props.get("name", "").upper()

            if not spns:
                continue
            if dontreqpreauth:
                continue
            if name.startswith("KRBTGT") or name.endswith("$"):
                continue

            user_obj = format_object(get_sid_by_name(name))
            rows.append([user_obj, ", ".join(spns)])

    return rows


def find_writable_gpos_targets(dir):
    global owned_sids, sid_to_type, sid_to_name, privileged_sids

    interesting_rights = {"GenericAll", "WriteDacl", "WriteOwner", "AllExtendedRights"}
    rows = []

    for file in find_files(dir, "gpos.json"):
        for entry in load_json_data(file):
            gpo_name = entry.get("Properties", {}).get("name", "N/A")
            gpo_sid = entry.get("ObjectIdentifier")

            links = entry.get("Links", [])
            if not links:
                gpo_target = "No Links"
            else:
                gpo_target = ""
                for link in links:
                    target_dn = link.get("TargetDN", "")
                    if "OU=Domain Controllers" in target_dn:
                        gpo_target = "Domain Controllers"
                        break
                    else:
                        gpo_target = target_dn or "Unknown"

            for ace in entry.get("Aces", []):
                right = ace.get("AceType") or ace.get("RightName")
                if right not in interesting_rights:
                    continue

                principal_sid = ace.get("PrincipalSID")
                if principal_sid in privileged_sids:
                    continue

                principal_obj = format_object(principal_sid)
                gpo_obj = format_object(gpo_sid)
                rows.append([principal_obj, right, gpo_obj, gpo_target])

    return rows


def render_section(title, color, headers, rows):
    if rows:
        console.print("\n")
        title_text = Text(f"{title}", style="bold " + color, justify="center")
        table = Table(title=title_text, box=box.MINIMAL_DOUBLE_HEAD, show_lines=True)
        for h in headers:
            table.add_column(h, style="bold cyan")
        if rows:
            for row in rows:
                table.add_row(*row)
        else:
            table.add_row("No findings", *[""] * (len(headers)-1))
        console.print(table)


def main(args):
    global owned_sids

    dir = extract_zip(args.file)
    build_sid_map(dir)
    get_domain_controllers_sids(dir)
    get_privileged_sids(dir)

    if args.users:
        export_object_list(dir, "users", args.users)

    if args.computers:
        export_object_list(dir, "computers", args.computers)


    if args.owned:
        with open(args.owned, "r", encoding="utf-8") as f:
            for line in f:
                name = line.strip()
                sid = get_sid_by_name(name)
                if sid:
                    owned_sids.add(sid)

    try:
        neo4j_owned = get_owned_sids_from_neo4j()
        owned_sids.update(neo4j_owned)
    except:
        pass


    render_section("Domain Controllers", 'yellow', ["SID", "Name"], [[sid, Text(decorations['computer']['icon'] + " " + name, style=decorations['computer']['color'])] for sid, name in sid_to_name.items() if sid in domain_controllers_sids])
    render_section("Domain/Enterprise Admins Members", 'yellow', ["Member Name", "Group Name"], check_domain_admins(dir))
    render_section("High Privileged Users (adminCount=1)", 'yellow', ["Username", "Distinguished Name"], check_admin_count(dir))
    render_section("Users With Remote Access to Computers", 'yellow', ["User", "Right", "Computer"], find_remote_access_users(dir))
    render_section("Users with Foreign Domain Group Membership", 'yellow', ["User", "Relation", "Foreign Group"], find_foreign_group_memberships(dir))
    render_section("Users with active session", 'yellow', ["User", "Relation", "Computer"], find_computers_with_sessions(dir))
    render_section("Overpass-the-Hash / Pass-the-Key candidates", 'yellow', ["User", "SPNs"], find_otp_pth_candidates(dir))
    render_section("Domain Trusts", 'red', ["Source", "Direction (Type)", "Target", "Abuse Type"], check_trusts(dir))
    render_section("Writable GPOs and their Targets", 'red', ["Principal", "Privilege", "GPO", "Target"], find_writable_gpos_targets(dir))
    render_section("Unconstrained Delegation", 'red', ["Hostname", "Operating System", "Organizational Unit", "Kerberoastable"], check_unconstrained_delegation(dir))
    render_section("Constrained Delegation", 'red', ["Hostname", "Delegation Type"], check_constrained_delegation(dir))
    render_section("Resource-Based Constrained Delegation", 'red', ["Target Host", "Allowed To Act From"], check_rbcd(dir))
    render_section("Users with SPN (Kerberoastable)", 'red', ["Username", "SPNs"], check_users_with_spn(dir))
    render_section("AS-REP Roastable Users", 'red', ["Username", "Distinguished Name"], find_asrep_roastable_users(dir))
    render_section("Interesting ACLs", 'red', ["Principal", "Ace Type", "Target"], check_interesting_acls(dir))
    render_section("Sensitive Descriptions (pass / pwd)", 'red', ["Object", "Description"], find_sensitive_descriptions(dir))
    render_section("Find dangerous permissions", 'red', ["Principal", "Right Name", "Target"], find_dangerous_permissions(dir))
    render_section("Foreign Group to Internal Group (Recursive Membership)", 'yellow', ["Foreign Group", "Relation", "Internal Group", "Path"], find_foreign_group_membership_chains(dir))
    render_section("Shadow Credentials (msDS-KeyCredentialLink)", 'red', ["Object", "KeyCredentialLink"], find_shadow_credentials(dir))
    render_section("Paths to High Privilege (Domain/Enterprise Admins)", 'magenta', ["From", "To", "Path"], find_paths_to_high_privilege(dir))


def parse_arguments():
    parser = argparse.ArgumentParser(description="BloodHound Legacy Analyzer")

    parser.add_argument("-f", "--file", required=True, action="append", help="Path to BloodHound zip file (use multiple -f to specify multiple files)")
    parser.add_argument("-o", "--owned", help="Path to a plaintext file with owned nodes (optional/one per line)", default=None)
    parser.add_argument("-u", "--users", help="Path to export list of users", default=None)
    parser.add_argument("-c", "--computers", help="Path to export list of computers", default=None)

    return parser.parse_args()


if __name__ == "__main__":
    args = parse_arguments()
    main(args)
