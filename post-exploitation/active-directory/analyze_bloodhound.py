#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Done
"""
- Unconstrained Delegation
- Constrained Delegation
- Resource-Based Constrained Delegation
- Users with SPN (Kerberoastable)
- AS-REP Roastable Users
- Interesting ACLs
- Sensitive Descriptions (pass / pwd)
- Find dangerous permissions
- High Privileged Users (adminCount=1)
- Users With Remote Access to Computers
- Users with Foreign Domain Group Membership
- Foreign Group to Internal Group (Recursive Membership)
- Domain Trusts
- Paths to High Privilege (Domain/Enterprise Admins)
- Export Users and Computers
- Neo4j integration to get owned sids
"""

# To-Do
"""
"""


import os
import json
import tempfile
import argparse
import networkx as nx
from zipfile import ZipFile
from rich import box
from rich.text import Text
from rich.table import Table
from rich.console import Console
from neo4j import GraphDatabase

console = Console()
sid_to_name = {}
sid_to_type = {}
domain_controllers_sids = set()
privileged_sids = set()
owned_sids = set()
decorations = {
    "user": {
        "color": "green",
        "icon": ""
    },
    "group": {
        "color": "yellow",
        "icon": ""
    },
    "computer": {
        "color": "magenta",
        "icon": "️"
    },
    "domain": {
        "color": "yellow",
        "icon": ""
    },
    "ou": {
        "color": "cyan",
        "icon": ""
    },
    "container": {
        "color": "white",
        "icon": ""
    },
    "gpo": {
        "color": "purple",
        "icon": "️"
    }
}


def extract_zip(zip_paths):
    temp_dir = tempfile.mkdtemp()
    for zip_path in zip_paths:
        with ZipFile(zip_path, 'r') as zip_ref:
            zip_ref.extractall(temp_dir)
    return temp_dir


def find_files(directory, keyword):
    return [os.path.join(directory, f) for f in os.listdir(directory) if keyword in f.lower()]


def load_json_data(path):
    try:
        with open(path, 'r', encoding='utf-8-sig') as f:
            content = json.load(f)
            return content.get("data", [])
    except Exception:
        return []


def export_object_list(dir, type_filter, output_file):
    exported = set()
    for file in find_files(dir, f"{type_filter}.json"):
        for entry in load_json_data(file):
            name = entry.get("Properties", {}).get("name")
            if name and name not in exported:
                exported.add(name)
    with open(output_file, "w", encoding="utf-8") as f:
        for item in sorted(exported):
            f.write(f"{item}\n")
    console.print(f"[green]Exported {len(exported)} {type_filter} to {output_file}[/]")


def build_sid_map(dir):
    global sid_to_name

    property_files = ["users", "groups", "computers", "domains", "ous", "containers", "gpos"]
    for keyword in property_files:
        for file in find_files(dir, f"{keyword}.json"):
            for entry in load_json_data(file):
                sid = entry.get("ObjectIdentifier")
                nombre = entry.get("Properties", {}).get("name")
                if sid and nombre:
                    sid_to_name[sid] = nombre
                    sid_to_type[sid] = keyword[:-1]


def get_sid_by_name(name):
    name = name.upper()
    for sid, n in sid_to_name.items():
        if n.upper() == name:
            return sid
    return None


def get_domain_controllers_sids(dir):
    global domain_controllers_sids

    dc_spn_indicators = [
        "ldap/",
        "GC/",
        "krbtgt/",
        "kadmin/",
        "DnsZones",
        "ForestDnsZones"
    ]
    for file in find_files(dir, "computers.json"):
        for entry in load_json_data(file):
            props = entry.get("Properties", {})
            sid = entry.get("ObjectIdentifier")
            spns = props.get("serviceprincipalnames", [])
            if any(any(indicator.lower() in spn.lower() for indicator in dc_spn_indicators) for spn in spns):
                domain_controllers_sids.add(sid)


def get_privileged_sids(dir):
    global privileged_sids
    
    for file in find_files(dir, "groups.json"):
        for entry in load_json_data(file):
            group_name = entry.get("Properties", {}).get("name", "").upper()
            group_sid = entry.get("ObjectIdentifier")
            if any(p in group_name for p in [
                "DOMAIN ADMINS", "ENTERPRISE ADMINS", "ADMINISTRATORS",
                "BACKUP OPERATORS", "ACCOUNT OPERATORS", "SERVER OPERATORS",
                "KRBTGT", "DNSADMINS", "KEY ADMINS", "RAS AND IAS SERVERS",
                "ENTERPRISE DOMAIN CONTROLLERS", "DOMAIN CONTROLLERS", "SCHEMA ADMINS"
            ]):
                if group_sid:
                    privileged_sids.add(group_sid)
                for member in entry.get("Members", []):
                    sid = member.get("ObjectIdentifier")
                    if sid:
                        privileged_sids.add(sid)


def get_owned_sids_from_neo4j():
    uri = 'bolt://localhost:7687'
    user = 'neo4j'
    password = 'kali'
    driver = GraphDatabase.driver(uri, auth=(user, password))
    owned = set()

    query = """
    MATCH (n)
    WHERE n.owned = true AND n.objectid IS NOT NULL
    RETURN n.objectid AS sid
    """

    with driver.session() as session:
        results = session.run(query)
        for record in results:
            sid = record["sid"]
            if sid:
                owned.add(sid)

    driver.close()
    return owned


def check_unconstrained_delegation(dir):
    global domain_controllers_sids

    rows = []
                        
    for file in find_files(dir, "computers.json"):
        for entry in load_json_data(file):
            props = entry.get("Properties", {})
            sid = entry.get("ObjectIdentifier")
            if props.get("unconstraineddelegation", False) and sid not in domain_controllers_sids:
                ou = " / ".join(part[3:] for part in props.get("distinguishedname", "").split(",") if part.startswith("OU="))
                dc_obj = Text(decorations['computer']['icon'] + " " + props.get("name", "N/A"), style=decorations['computer']['color'])
                rows.append([dc_obj, props.get("operatingsystem", "N/A"), ou or "N/A"])
    return rows


def check_constrained_delegation(dir):
    global owned_sids

    rows = []
    for file in find_files(dir, "computers.json"):
        for entry in load_json_data(file):
            props = entry.get("Properties", {})
            if props.get("trustedtoauth", False):
                skull = "" if get_sid_by_name(props.get("name", "N/A")) in owned_sids else ""
                dc_obj = Text(decorations['computer']['icon'] + skull +" " + props.get("name", "N/A"), style=decorations['computer']['color'])
                rows.append([dc_obj, "ProtocolTransition"])
    return rows


def check_rbcd(dir):
    global owned_sids
    
    rows = []
    for file in find_files(dir, "computers.json"):
        for entry in load_json_data(file):
            if "AllowedToAct" in entry and entry["AllowedToAct"]:
                for act in entry["AllowedToAct"]:
                    type = sid_to_type.get(get_sid_by_name(entry["Properties"]["name"]), "N/A")
                    skull = "" if get_sid_by_name(entry["Properties"]["name"]) in owned_sids else ""
                    obj1 = Text(decorations[type]['icon'] + skull + " " + entry["Properties"]["name"] if type in decorations else "", style=decorations[type]['color'] if type in decorations else "cyan")
                    type = sid_to_type.get(get_sid_by_name(act.get("PrincipalName", "N/A")), "N/A")
                    skull = "" if get_sid_by_name(act.get("PrincipalName", "N/A")) in owned_sids else ""
                    obj2 = Text(decorations[type]['icon'] + skull + " " + act.get("PrincipalName", "N/A") if type in decorations else "", style=decorations[type]['color'] if type in decorations else "cyan")
                    rows.append([obj1, obj2])
    return rows


def check_users_with_spn(dir):
    global owned_sids
    
    rows = []
    for file in find_files(dir, "users.json"):
        for entry in load_json_data(file):
            props = entry.get("Properties", {})
            spns = props.get("serviceprincipalnames", [])
            if spns:
                skull = "" if get_sid_by_name(props.get("name", "N/A")) in owned_sids else ""
                user_obj = Text(decorations['user']['icon'] + skull + " " + props.get("name", "N/A"), style=decorations['user']['color'])
                rows.append([user_obj, ", ".join(spns)])
    return rows


def check_admin_count(dir):
    global owned_sids
    
    rows = []
    for file in find_files(dir, "users.json"):
        for entry in load_json_data(file):
            props = entry.get("Properties", {})
            if props.get("admincount", 0) == 1:
                type = sid_to_type.get(get_sid_by_name(props.get("name", "N/A")), "N/A")
                skull = "" if get_sid_by_name(props.get("name", "N/A")) in owned_sids else ""
                obj = Text(decorations[type]['icon'] + skull + " " + props.get("name", "N/A") if type in decorations else "", style=decorations[type]['color'] if type in decorations else "cyan")
                rows.append([obj, props.get("distinguishedname", "N/A")])
    return rows


def check_trusts(dir):
    global owned_sids

    rows = []
    domain_data = {}
    seen_trusts = set()

    for file in find_files(dir, "domains.json"):
        for entry in load_json_data(file):
            domain_sid = entry.get("ObjectIdentifier")
            domain_name = entry.get("Properties", {}).get("name", "N/A")
            trusts = entry.get("Trusts", [])
            domain_data[domain_sid] = {
                "name": domain_name,
                "trusts": trusts
            }

    for source_sid, source_info in domain_data.items():
        source_name = source_info["name"]
        for trust in source_info["trusts"]:
            target_sid = trust.get("TargetDomainSid")
            target_name = trust.get("TargetDomainName", "N/A")
            direction = trust.get("TrustDirection", 0)
            trust_type = trust.get("TrustType", 0)
            transitive = trust.get("IsTransitive", True)
            selective_auth = trust.get("IsSelectiveAuth", False)
            sid_filtering = trust.get("SidFilteringEnabled", True)

            key = tuple(sorted([source_sid, target_sid or target_name]))
            if key in seen_trusts:
                continue
            seen_trusts.add(key)

            direction_str = {
                0: "Disabled",
                1: "Inbound",
                2: "Outbound",
                3: "Bidirectional"
            }.get(direction, str(direction))

            trust_type_str = {
                0: "Disabled/Unknown",
                1: "Windows",
                2: "Kerberos",
                3: "MIT",
                4: "DCE"
            }.get(trust_type, str(trust_type))

            abuses = []

            if trust_type == 2 and transitive and direction in {2, 3} and not selective_auth:
                abuses.append("Silver Ticket")

            if direction in {1, 3} and trust_type == 2 and not selective_auth:
                abuses.append("Golden Ticket")

            if not sid_filtering:
                abuses.append("SIDHistory")

            abuse_text = Text(", ".join(abuses), style="red" if abuses else "grey62")

            skull = "" if source_sid in owned_sids else ""
            source_obj = Text(f"{decorations['domain']['icon']}{skull} {source_name}", style=decorations['domain']['color'])

            if target_sid in domain_data:
                skull = "" if target_sid in owned_sids else ""
                target_name = domain_data[target_sid]["name"]
                target_obj = Text(f"{decorations['domain']['icon']}{skull} {target_name}", style=decorations['domain']['color'])
            else:
                target_obj = Text(f"{decorations['domain']['icon']} {target_name}", style=decorations['domain']['color'])

            rows.append([source_obj, f"{direction_str} ({trust_type_str})", target_obj, abuse_text])

    return rows


def check_domain_admins(dir):
    global owned_sids
    
    rows = []
    for file in find_files(dir, "groups.json"):
        for entry in load_json_data(file):
            group_name = entry.get("Properties", {}).get("name", "").upper()
            if group_name.startswith("DOMAIN ADMINS") or group_name.startswith("ENTERPRISE ADMINS"):
                for member in entry.get("Members", []):
                    sid = member.get("ObjectIdentifier", "N/A")
                    name = sid_to_name.get(sid, sid)
                    type = sid_to_type.get(sid, "N/A")
                    skull = "" if sid in owned_sids else ""
                    user_obj = Text(decorations[type]['icon'] + skull + " " + name if type in decorations else "", style=decorations[type]['color'] if type in decorations else "cyan")
                    skull = "" if get_sid_by_name(group_name) in owned_sids else ""
                    group_obj = Text(decorations['group']['icon'] + skull + " " + group_name, style=decorations['group']['color'])
                    rows.append([user_obj, group_obj])
    return rows


def check_interesting_acls(dir):
    global privileged_sids, owned_sids
    rows = []
    interesting_rights = {
        "GenericAll", "GenericWrite", "WriteDacl", "WriteOwner",
        "AllExtendedRights", "ResetPassword", "CreateChild", "DeleteChild",
        "AddMember", "WriteSPN", "ForceChangePassword", "ReadGMSAPassword",
        "ReadLAPSPassword", "WriteProperty", "Owns"
    }

    for file in find_files(dir, "acls.json"):
        for entry in load_json_data(file):
            ace_type = entry.get("AceType")
            right_name = entry.get("RightName")
            if ace_type in interesting_rights or right_name in interesting_rights:
                principal = entry.get("PrincipalName", "N/A")
                sid = get_sid_by_name(principal)
                if sid in privileged_sids:
                    continue
                target = entry.get("TargetName", "N/A")
                privilege = ace_type if ace_type in interesting_rights else right_name
                type = sid_to_type.get(get_sid_by_name(principal), "N/A")
                skull = "" if get_sid_by_name(principal) in owned_sids else ""
                principal_obj = Text(decorations[type]['icon'] + skull + " " + principal if type in decorations else "", style=decorations[type]['color'] if type in decorations else "cyan")
                rows.append([principal_obj, privilege, target])

    for keyword in ["computers", "users", "groups", "containers", "domains", "gpos", "ous"]:
        for file in find_files(dir, f"{keyword}.json"):
            for entry in load_json_data(file):
                target = entry.get("Properties", {}).get("name", "N/A")
                aces = entry.get("Aces", [])
                for ace in aces:
                    ace_type = ace.get("AceType")
                    right_name = ace.get("RightName")
                    privilege = ace_type if ace_type in interesting_rights else right_name
                    if privilege in interesting_rights:
                        sid = ace.get("PrincipalSID", "")
                        principal = sid_to_name.get(sid)
                        if not principal:
                            principal = sid.upper()
                        if not principal:
                            principal = ace.get("PrincipalName") or sid
                        sid = ace.get("PrincipalSID", "")
                        if sid in privileged_sids:
                            continue
                        type = sid_to_type.get(get_sid_by_name(principal), "N/A")
                        skull = "" if get_sid_by_name(principal) in owned_sids else ""
                        principal_obj = Text(decorations[type]['icon'] + skull + " " + principal if type in decorations else "", style=decorations[type]['color'] if type in decorations else "cyan")
                        type = sid_to_type.get(get_sid_by_name(target), "N/A")
                        skull = "" if get_sid_by_name(target) in owned_sids else ""
                        target_obj = Text(decorations[type]['icon'] + skull + " " + target if type in decorations else "", style=decorations[type]['color'] if type in decorations else "cyan")
                        
                        if sid_to_type.get(sid) == "group":
                            for file in find_files(dir, "groups.json"):
                                for group_entry in load_json_data(file):
                                    if group_entry.get("ObjectIdentifier") == sid:
                                        for member in group_entry.get("Members", []):
                                            member_sid = member.get("ObjectIdentifier")
                                            member_name = sid_to_name.get(member_sid, member_sid)
                                            member_type = sid_to_type.get(member_sid, "N/A")
                                            icon = decorations[member_type]['icon'] if member_type in decorations else ""
                                            color = decorations[member_type]['color'] if member_type in decorations else "cyan"
                                            skull = "" if get_sid_by_name(member_sid) in owned_sids else ""
                                            line = Text(f"\n  ↳ {icon}{skull} {member_name}", style=color)
                                            principal_obj.append(line)
                                        break
                        
                        rows.append([principal_obj, privilege, target_obj])
    
    return rows


def find_sensitive_descriptions(dir):
    global owned_sids
    
    rows = []
    keywords = ["pass", "pwd"]
    for file in find_files(dir, "users.json") + find_files(dir, "computers.json"):
        for entry in load_json_data(file):
            props = entry.get("Properties", {})
            desc = (props.get("description") or "").lower()
            if any(k in desc for k in keywords):
                type = sid_to_type.get(get_sid_by_name(props.get("name", "N/A")), "N/A")
                skull = "" if get_sid_by_name(props.get("name", "N/A")) in owned_sids else ""
                obj = Text(decorations[type]['icon'] + skull + " " + props.get("name", "N/A") if type in decorations else "", style=decorations[type]['color'] if type in decorations else "cyan")
                rows.append([obj, props.get("description", "N/A")])
    return rows


def find_dangerous_permissions(dir):
    global owned_sids
    
    rows = []
    rights_needed = [
        "DS-Replication-Get-Changes",
        "DS-Replication-Get-Changes-All",
        "DS-Replication-Get-Changes-In-Filtered-Set"
    ]
    for file in find_files(dir, "acls.json"):
        for entry in load_json_data(file):
            if (entry.get("RightName") in rights_needed and "DOMAIN" in entry.get("TargetName", "").upper()) or entry.get("RightName") == "ReadGMSAPassword" or entry.get("RightName") == "ReadLAPSPassword":
                type = sid_to_type.get(get_sid_by_name(entry.get("PrincipalName", "N/A")), "N/A")
                skull = "" if get_sid_by_name(entry.get("PrincipalName", "N/A")) in owned_sids else ""
                principal_obj = Text(decorations[type]['icon'] + skull + " " + entry.get("PrincipalName", "N/A") if type in decorations else "", style=decorations[type]['color'] if type in decorations else "cyan")
                type = sid_to_type.get(get_sid_by_name(entry.get("TargetName", "N/A")), "N/A")
                skull = "" if get_sid_by_name(entry.get("TargetName", "N/A")) in owned_sids else ""
                target_obj = Text(decorations[type]['icon'] + skull + " " + entry.get("TargetName", "N/A") if type in decorations else "", style=decorations[type]['color'] if type in decorations else "cyan")
                rows.append([principal_obj, entry.get("RightName", "N/A"), target_obj])
    return rows


def find_asrep_roastable_users(dir):
    global owned_sids
    
    rows = []
    for file in find_files(dir, "users.json"):
        for entry in load_json_data(file):
            props = entry.get("Properties", {})
            if props.get("dontreqpreauth", False):
                type = sid_to_type.get(get_sid_by_name(props.get("name", "N/A")), "N/A")
                skull = "" if get_sid_by_name(props.get("name", "N/A")) in owned_sids else ""
                obj = Text(decorations[type]['icon'] + skull + " " + props.get("name", "N/A") if type in decorations else "", style=decorations[type]['color'] if type in decorations else "cyan")
                rows.append([obj, props.get("distinguishedname", "N/A")])
    return rows


def find_paths_to_high_privilege(dir):
    global privileged_sids, owned_sids

    G = nx.DiGraph()
    
    all_files = find_files(dir, ".json")
    for file in all_files:
        for entry in load_json_data(file):
            oid = entry.get("ObjectIdentifier")
            name = entry.get("Properties", {}).get("name")
            if oid and name:
                G.add_node(oid, label=name)
    
    for file in find_files(dir, ".json"):
        for entry in load_json_data(file):
            member = entry.get("MemberId")
            group = entry.get("GroupId")
            if member and group:
                G.add_edge(member, group, type="MemberOf")
    
    interesting_edges = {"GenericAll", "WriteDacl", "AddMember", "ResetPassword", "WriteSPN", "Owns", "WriteOwner", "AllExtendedRights"}
    for file in find_files(dir, ".json"):
        for entry in load_json_data(file):
            target = entry.get("ObjectIdentifier")
            aces = entry.get("Aces", [])
            for ace in aces:
                source = ace.get("PrincipalSID")
                right = ace.get("RightName") or ace.get("AceType")
                if source and target and right in interesting_edges:
                    G.add_edge(source, target, type=right)

    for file in find_files(dir, "groups.json"):
        for entry in load_json_data(file):
            group_sid = entry.get("ObjectIdentifier")
            for member in entry.get("Members", []):
                member_sid = member.get("ObjectIdentifier")
                if group_sid and member_sid:
                    G.add_edge(member_sid, group_sid, type="MemberOf")

    targets = set()
    for node in G.nodes:
        name = sid_to_name.get(node, "").upper()
        if name.startswith("DOMAIN ADMINS") or name.startswith("ENTERPRISE ADMINS") or name.startswith("ADMINISTRATORS") or name.startswith("BACKUP OPERATORS") or name.startswith("ACCOUNT OPERATORS") or name.startswith("SERVER OPERATORS") or get_sid_by_name(name) in domain_controllers_sids:
            targets.add(node)
    
    low_priv_users = set()
    for sid, name in sid_to_name.items():
        shortname = name.split("@")[0].upper()
        if sid in privileged_sids or shortname in {"ADMINISTRATORS", "ADMINISTRATOR", "BACKUP OPERATORS", "ACCOUNT OPERATORS", "SERVER OPERATORS", "KRBTGT"}:
            continue
        if name.split("@")[0].upper() not in {"ADMINISTRATOR", "KRBTGT"} and "@" in name:
            low_priv_users.add(sid)
    
    rows = []
    for user in low_priv_users:
        for target in targets:
            try:
                path = nx.shortest_path(G, user, target)
                if any(n in targets for n in path[1:-1]):
                    continue
                readable_path = Text()
                for i, node in enumerate(path):
                    tipo = sid_to_type.get(node, "N/A")
                    decor = decorations.get(tipo, {"icon": "", "color": "cyan"})
                    nombre = sid_to_name.get(node, node)
                    skull = "" if node in owned_sids else ""
                    nodo_text = Text(f"{decor['icon']}{skull} {nombre}", style=decor['color'])
                    readable_path.append(nodo_text)
                    if i < len(path) - 1:
                        readable_path.append(" → ", style="white")
                type = sid_to_type.get(user, "N/A")
                skull = "" if user in owned_sids else ""
                from_obj = Text(decorations[type]['icon'] + skull + " " + sid_to_name.get(user, user) if type in decorations else "", style=decorations[type]['color'] if type in decorations else "cyan")
                type = sid_to_type.get(target, "N/A")
                skull = "" if target in owned_sids else ""
                to_obj = Text(decorations[type]['icon'] + skull + " " + sid_to_name.get(target, target) if type in decorations else "", style=decorations[type]['color'] if type in decorations else "cyan")
                rows.append([from_obj, to_obj, readable_path])
            except nx.NetworkXNoPath:
                continue

    return rows


def find_remote_access_users(dir):
    global sid_to_name, sid_to_type

    remote_access_rights = {
        "RemoteInteractiveLogon",  # RDP-like
        "ExecuteMethods",          # WMI
        "DCOM"                     # WinRM/DCOM
    }

    rows = []

    for file in find_files(dir, "acls.json"):
        for entry in load_json_data(file):
            target_name = entry.get("TargetName", "N/A")
            target_sid = get_sid_by_name(target_name)
            target_type = sid_to_type.get(target_sid, "computer")
            if target_type != "computer":
                continue

            right = entry.get("RightName") or entry.get("AceType")
            if right not in remote_access_rights:
                continue

            principal = entry.get("PrincipalName") or entry.get("PrincipalSID", "N/A")
            sid = get_sid_by_name(principal)
            type = sid_to_type.get(sid, "N/A")

            if sid in privileged_sids:
                continue

            user_icon = decorations[type]['icon'] if type in decorations else ""
            user_color = decorations[type]['color'] if type in decorations else "cyan"
            skull = "" if sid in owned_sids else ""
            user_obj = Text(user_icon + skull + " " + principal, style=user_color)

            comp_icon = decorations[target_type]['icon'] if target_type in decorations else ""
            comp_color = decorations[target_type]['color'] if target_type in decorations else "cyan"
            skull = "" if target_sid in owned_sids else ""
            comp_obj = Text(comp_icon + skull + " " + target_name, style=comp_color)

            rows.append([user_obj, right, comp_obj])

    return rows


def find_foreign_group_memberships(dir):
    global privileged_sids, owned_sids

    rows = []

    for file in find_files(dir, "groups.json"):
        for entry in load_json_data(file):
            group_sid = entry.get("ObjectIdentifier")
            group_name = sid_to_name.get(group_sid, group_sid)

            for member in entry.get("Members", []):
                member_sid = member.get("ObjectIdentifier")
                member_name = sid_to_name.get(member_sid, member_sid)

                if member_sid in privileged_sids:
                    continue

                if "@" not in member_name or "@" not in group_name:
                    continue

                user_domain = member_name.split("@")[-1].lower()
                group_domain = group_name.split("@")[-1].lower()

                if user_domain != group_domain:
                    member_type = sid_to_type.get(member_sid, "user")
                    group_type = sid_to_type.get(group_sid, "group")
                    skull = "" if member_sid in owned_sids else ""
                    user_obj = Text(decorations[member_type]['icon'] + skull + " " + member_name, style=decorations[member_type]['color'])
                    skull = "" if group_sid in owned_sids else ""
                    group_obj = Text(decorations[group_type]['icon'] + skull + " " + group_name, style=decorations[group_type]['color'])

                    rows.append([user_obj, "MemberOf", group_obj])

    return rows


def find_foreign_group_membership_chains(dir):
    rows = []
    G = nx.DiGraph()

    for file in find_files(dir, "groups.json"):
        for entry in load_json_data(file):
            group_sid = entry.get("ObjectIdentifier")
            group_name = sid_to_name.get(group_sid, group_sid)

            for parent in entry.get("MemberOf", []):
                parent_sid = parent.get("ObjectIdentifier")
                G.add_edge(group_sid, parent_sid)

    for source_sid in G.nodes:
        source_name = sid_to_name.get(source_sid, "")
        if "@" not in source_name:
            continue

        source_domain = source_name.split("@")[-1].lower()
        if source_domain == "capsulecorp.local":
            continue

        for target_sid in G.nodes:
            if source_sid == target_sid:
                continue

            target_name = sid_to_name.get(target_sid, "")
            if "@" not in target_name:
                continue

            target_domain = target_name.split("@")[-1].lower()
            if target_domain == source_domain:
                continue

            try:
                path = nx.shortest_path(G, source=source_sid, target=target_sid)
                if len(path) > 1:
                    from_type = sid_to_type.get(source_sid, "group")
                    to_type = sid_to_type.get(target_sid, "group")
                    skull = "" if source_sid in owned_sids else ""
                    from_obj = Text(decorations[from_type]['icon'] + skull + " " + source_name, style=decorations[from_type]['color'])
                    skull = "" if target_sid in owned_sids else ""
                    to_obj = Text(decorations[to_type]['icon'] + skull + " " + target_name, style=decorations[to_type]['color'])
                    path_text = Text(" → ".join([sid_to_name.get(s, s) for s in path]), style="dim")

                    rows.append([from_obj, "MemberOf*", to_obj, path_text])
            except nx.NetworkXNoPath:
                continue

    return rows


def render_section(title, color, headers, rows):
    if rows:
        console.print("\n")
        title_text = Text(f"{title}", style="bold " + color, justify="center")
        table = Table(title=title_text, box=box.MINIMAL_DOUBLE_HEAD, show_lines=True)
        for h in headers:
            table.add_column(h, style="bold cyan")
        if rows:
            for row in rows:
                table.add_row(*row)
        else:
            table.add_row("No findings", *[""] * (len(headers)-1))
        console.print(table)


def main(args):
    global owned_sids

    dir = extract_zip(args.file)
    build_sid_map(dir)
    get_domain_controllers_sids(dir)
    get_privileged_sids(dir)

    if args.users:
        export_object_list(dir, "users", args.users)

    if args.computers:
        export_object_list(dir, "computers", args.computers)


    if args.owned:
        with open(args.owned, "r", encoding="utf-8") as f:
            for line in f:
                name = line.strip()
                sid = get_sid_by_name(name)
                if sid:
                    owned_sids.add(sid)

    try:
        neo4j_owned = get_owned_sids_from_neo4j()
        owned_sids.update(neo4j_owned)
    except Exception as e:
        pass

    render_section("Domain Controllers", 'yellow', ["SID", "Name"], [[sid, Text(decorations['computer']['icon'] + " " + name, style=decorations['computer']['color'])] for sid, name in sid_to_name.items() if sid in domain_controllers_sids])
    render_section("Domain/Enterprise Admins Members", 'yellow', ["Member Name", "Group Name"], check_domain_admins(dir))
    render_section("Unconstrained Delegation", 'red', ["Hostname", "Operating System", "Organizational Unit"], check_unconstrained_delegation(dir))
    render_section("Constrained Delegation", 'red', ["Hostname", "Delegation Type"], check_constrained_delegation(dir))
    render_section("Resource-Based Constrained Delegation", 'red', ["Target Host", "Allowed To Act From"], check_rbcd(dir))
    render_section("Users with SPN (Kerberoastable)", 'red', ["Username", "SPNs"], check_users_with_spn(dir))
    render_section("AS-REP Roastable Users", 'red', ["Username", "Distinguished Name"], find_asrep_roastable_users(dir))
    render_section("Interesting ACLs", 'red', ["Principal", "Ace Type", "Target"], check_interesting_acls(dir))
    render_section("Sensitive Descriptions (pass / pwd)", 'red', ["Object", "Description"], find_sensitive_descriptions(dir))
    render_section("Find dangerous permissions", 'red', ["Principal", "Right Name", "Target"], find_dangerous_permissions(dir))
    render_section("High Privileged Users (adminCount=1)", 'red', ["Username", "Distinguished Name"], check_admin_count(dir))
    render_section("Users With Remote Access to Computers", 'yellow', ["User", "Right", "Computer"], find_remote_access_users(dir))
    render_section("Users with Foreign Domain Group Membership", 'yellow', ["User", "Relation", "Foreign Group"], find_foreign_group_memberships(dir))
    render_section("Foreign Group to Internal Group (Recursive Membership)", 'yellow', ["Foreign Group", "Relation", "Internal Group", "Path"], find_foreign_group_membership_chains(dir))
    render_section("Domain Trusts", 'red', ["Source", "Direction (Type)", "Target", "Abuse Type"], check_trusts(dir))
    render_section("Paths to High Privilege (Domain/Enterprise Admins)", 'magenta', ["From", "To", "Path"], find_paths_to_high_privilege(dir))


def parse_arguments():
    parser = argparse.ArgumentParser(description="BloodHound Legacy Analyzer")

    parser.add_argument("-f", "--file", required=True, action="append", help="Path to BloodHound zip file (use multiple -f to specify multiple files)")
    parser.add_argument("-o", "--owned", help="Path to a plaintext file with owned nodes (optional/one per line)", default=None)
    parser.add_argument("-u", "--users", help="Path to export list of users", default=None)
    parser.add_argument("-c", "--computers", help="Path to export list of computers", default=None)

    return parser.parse_args()


if __name__ == "__main__":
    args = parse_arguments()
    main(args)
